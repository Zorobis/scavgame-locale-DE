name: Validate locale files (EN.json vs DE.json)

on:
  push:
    paths:
      - "EN.json"
      - "DE.json"
  pull_request:
    paths:
      - "EN.json"
      - "DE.json"

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Validate EN.json ⇄ DE.json structure and types
        # uses inline NodeJS to avoid separate script files
        run: |
          node <<'NODE'
          const fs = require('fs');

          function load(file) {
            try {
              return JSON.parse(fs.readFileSync(file, 'utf8'));
            } catch (e) {
              console.error(`❌ Invalid JSON in ${file}: ${e.message}`);
              process.exit(1);
            }
          }

          const en = load('EN.json');
          const de = load('DE.json');

          function typeOf(v) {
            if (Array.isArray(v)) return 'array';
            if (v === null) return 'null';
            return typeof v;
          }

          const missing = [];
          const extra = [];
          const typeMismatches = [];
          const arrayIssues = [];

          // Recursively compare structures.
          function compare(enNode, deNode, path) {
            const enType = typeOf(enNode);
            const deType = typeOf(deNode);

            if (enType !== deType) {
              typeMismatches.push({ path, expected: enType, found: deType });
              // if type differs, stop deeper checks on this branch
              return;
            }

            if (enType === 'object') {
              // both objects: compare keys
              const enKeys = Object.keys(enNode);
              const deKeys = Object.keys(deNode);

              enKeys.forEach(k => {
                if (!(k in deNode)) missing.push(path ? `${path}.${k}` : k);
                else compare(enNode[k], deNode[k], path ? `${path}.${k}` : k);
              });

              deKeys.forEach(k => {
                if (!(k in enNode)) extra.push(path ? `${path}.${k}` : k);
              });
            } else if (enType === 'array') {
              // both arrays: check lengths and compare elements by index
              const enLen = enNode.length;
              const deLen = deNode.length;
              if (enLen !== deLen) {
                arrayIssues.push({
                  path,
                  enLength: enLen,
                  deLength: deLen,
                  note: `expected ${enLen} items, found ${deLen}`
                });
              }
              const min = Math.min(enLen, deLen);
              for (let i = 0; i < min; i++) {
                compare(enNode[i], deNode[i], `${path}[${i}]`);
              }
              // If DE shorter, list missing indices
              if (deLen < enLen) {
                for (let i = deLen; i < enLen; i++) {
                  missing.push(`${path}[${i}]`);
                }
              }
              // If DE longer, list extra indices
              if (deLen > enLen) {
                for (let i = enLen; i < deLen; i++) {
                  extra.push(`${path}[${i}]`);
                }
              }
            } else {
              // primitive (string/number/boolean/null): no deeper structure to compare
              // Optionally: enforce that EN leaf is string (most translations) and DE leaf too
            }
          }

          compare(en, de, '');

          // Check for "leaf value type" mismatches specifically (helpful for translators)
          // e.g., if EN value is string but DE is array/object etc. Already covered by typeMismatches.

          // Pretty print results
          const anyProblems = missing.length || extra.length || typeMismatches.length || arrayIssues.length;

          if (anyProblems) {
            console.error('❌ Locale validation failed:');

            if (missing.length) {
              console.error(`\n  ❗ ${missing.length} missing path(s) in DE.json:`);
              missing.slice(0, 200).forEach(p => console.error(`    - ${p}`));
            }

            if (extra.length) {
              console.error(`\n  ⚠️ ${extra.length} extra path(s) in DE.json (not in EN.json):`);
              extra.slice(0, 200).forEach(p => console.error(`    - ${p}`));
            }

            if (typeMismatches.length) {
              console.error(`\n  🔄 ${typeMismatches.length} type mismatch(es):`);
              typeMismatches.forEach(t => {
                console.error(`    - ${t.path}: expected ${t.expected}, found ${t.found}`);
              });
            }

            if (arrayIssues.length) {
              console.error(`\n  🧾 ${arrayIssues.length} array length issue(s):`);
              arrayIssues.forEach(a => {
                console.error(`    - ${a.path}: ${a.note}`);
              });
            }

            console.error('\nHint: paths use dot notation for objects and [index] for arrays, e.g. notes[0].Item1');
            process.exit(1);
          } else {
            console.log('✅ DE.json matches EN.json structure and types (arrays & nested values checked).');
          }
          NODE
